<!-- settings.html â€” Qvink Memory (headless-compatible) -->
<div id="qvink_memory_settings" class="qvink_memory_settings_content">
  <div class="inline-drawer">
    <div class="inline-drawer-toggle inline-drawer-header">
      <div class="flex-container alignitemscenter margin0">
        <b id="qvink_title" title="Message Summarize">Qvink Memory</b>
        <i id="qvink_popout_button" title="Move config to floating popout" class="fa-solid fa-window-restore menu_button margin0"></i>
      </div>
      <div class="inline-drawer-icon fa-solid fa-circle-chevron-down down"></div>
    </div>

    <div class="inline-drawer-content">
      <div class="qvink_memory_settings_content">
        <hr>
        <div class="flex-container justifyspacebetween alignitemscenter">
          <button id="toggle_chat_memory" class="menu_button flex2"><span>Toggle Memory</span></button>
          <button id="refresh_memory" class="menu_button fa-solid fa-sync margin0" title="Refresh memory state"></button>
        </div>

        <hr>
        <h4 class="textAlignCenter">Summarization</h4>

        <label class="checkbox_label">
          <input id="auto_summarize" type="checkbox" />
          <span>Auto Summarize</span>
        </label>

        <label class="checkbox_label">
          <input id="auto_summarize_on_send" type="checkbox" />
          <span>Before Generation</span>
        </label>

        <div class="flex-container justifyspacebetween alignitemscenter" style="margin-top:8px;">
          <label style="display:flex;align-items:center;">
            <span style="margin-right:.5em">Short-term limit</span>
            <input id="short_term_context_limit" type="number" min="0" style="width:7em" />
          </label>

          <label style="display:flex;align-items:center;">
            <span style="margin-right:.5em">Long-term limit</span>
            <input id="long_term_context_limit" type="number" min="0" style="width:7em" />
          </label>
        </div>

        <hr>
        <h4 class="textAlignCenter">Misc.</h4>

        <label class="checkbox_label">
          <input id="debug_mode" type="checkbox" />
          <span>Debug Mode</span>
        </label>

        <div style="display:flex;gap:.5rem;justify-content:flex-end;margin-top:8px;">
          <button id="revert_settings" class="menu_button">Revert</button>
          <button id="save_settings" class="menu_button">Save</button>
        </div>

        <hr>

        <div style="font-size:0.9em;color:var(--muted-color,#666);margin-top:6px;">
          This UI talks to window.qvink_memory (the extension runtime). If you prefer a tiny popup, use qvink_memory.openTinyUI().
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(function () {
  // Robust wiring: wait for the qvink_memory API to be available.
  // Poll for it up to ~5 seconds (50 attempts at 100ms).
  function safeById(id) { return document.getElementById(id); }

  // Elements
  const EL = {
    auto_summarize: safeById('auto_summarize'),
    auto_summarize_on_send: safeById('auto_summarize_on_send'),
    short_term_context_limit: safeById('short_term_context_limit'),
    long_term_context_limit: safeById('long_term_context_limit'),
    debug_mode: safeById('debug_mode'),
    save_settings: safeById('save_settings'),
    revert_settings: safeById('revert_settings'),
    refresh_memory: safeById('refresh_memory'),
    toggle_chat_memory: safeById('toggle_chat_memory')
  };

  // default UI values in case settings API isn't available yet
  const UI_DEFAULTS = {
    auto_summarize: false,
    auto_summarize_on_send: false,
    short_term_context_limit: 2000,
    long_term_context_limit: 8000,
    debug_mode: false
  };

  // populate UI from a settings object
  function populateUI(settings = {}) {
    const s = Object.assign({}, UI_DEFAULTS, settings || {});
    if (EL.auto_summarize) EL.auto_summarize.checked = !!s.auto_summarize;
    if (EL.auto_summarize_on_send) EL.auto_summarize_on_send.checked = !!s.auto_summarize_on_send;
    if (EL.short_term_context_limit) EL.short_term_context_limit.value = s.short_term_context_limit ?? '';
    if (EL.long_term_context_limit) EL.long_term_context_limit.value = s.long_term_context_limit ?? '';
    if (EL.debug_mode) EL.debug_mode.checked = !!s.debug_mode;
  }

  // read UI values to a settings object
  function readUI() {
    return {
      auto_summarize: !!(EL.auto_summarize && EL.auto_summarize.checked),
      auto_summarize_on_send: !!(EL.auto_summarize_on_send && EL.auto_summarize_on_send.checked),
      short_term_context_limit: parseInt(EL.short_term_context_limit?.value || 0, 10) || 0,
      long_term_context_limit: parseInt(EL.long_term_context_limit?.value || 0, 10) || 0,
      debug_mode: !!(EL.debug_mode && EL.debug_mode.checked)
    };
  }

  // Wiring (attach UI listeners) - called once qvink_memory exists
  function wireToAPI(api) {
    // get initial settings and populate
    api.getSettings().then(populateUI).catch(() => populateUI());

    // Save button
    if (EL.save_settings) {
      EL.save_settings.addEventListener('click', async () => {
        const s = readUI();
        await api.setSettings(s);
        if (s.debug_mode) console.log('qvink_memory: settings saved from UI', s);
      });
    }

    // Revert - load defaults from API (we rely on the API's defaults if provided)
    if (EL.revert_settings) {
      EL.revert_settings.addEventListener('click', async () => {
        // Attempt to re-load from API (which may hold default profile)
        const fresh = await api.getSettings().catch(() => null);
        // If API returned null, use UI_DEFAULTS
        populateUI(fresh || UI_DEFAULTS);
      });
    }

    // Live changes for important toggles (optional)
    if (EL.auto_summarize) {
      EL.auto_summarize.addEventListener('change', async () => {
        const partial = { auto_summarize: !!EL.auto_summarize.checked };
        await api.setSettings(partial);
      });
    }
    if (EL.short_term_context_limit) {
      EL.short_term_context_limit.addEventListener('change', async () => {
        const val = parseInt(EL.short_term_context_limit.value || 0, 10) || 0;
        await api.setSettings({ short_term_context_limit: val });
      });
    }

    // refresh memory / toggle memory buttons: call provided API hooks if present
    if (EL.refresh_memory) {
      EL.refresh_memory.addEventListener('click', () => {
        if (typeof api.refreshMemory === 'function') api.refreshMemory();
        else if (api.getContext && api.getContext()) {
          try { const ctx = api.getContext(); if (ctx && ctx.emit) ctx.emit('extension_request_refresh'); } catch(e) {}
        }
      });
    }

    if (EL.toggle_chat_memory) {
      EL.toggle_chat_memory.addEventListener('click', () => {
        // If there is a programmatic toggle, call it; otherwise flip a setting
        if (typeof api.toggle === 'function') {
          api.toggle('auto_summarize'); // sample toggle - adapt as needed
        } else {
          readUI(); // noop
        }
      });
    }
  }

  // Poll for qvink_memory API
  let attempts = 0;
  const maxAttempts = 50;
  const poll = setInterval(() => {
    attempts++;
    if (window.qvink_memory && typeof window.qvink_memory.getSettings === 'function') {
      clearInterval(poll);
      try {
        wireToAPI(window.qvink_memory);
      } catch (e) { console.error('qvink_memory settings UI wiring failed:', e); }
      return;
    }
    if (attempts >= maxAttempts) {
      clearInterval(poll);
      // Fallback: populate UI with defaults so settings.html is usable even offline
      populateUI();
      console.warn('qvink_memory: API not available; settings UI loaded with defaults.');
    }
  }, 100);

  // Also populate quickly with defaults while waiting for API
  populateUI();

})();
</script>
